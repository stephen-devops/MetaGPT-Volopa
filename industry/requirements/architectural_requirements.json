{
  "meta": {
    "title": "Laravel Architectural Requirements - LaravelArchitect",
    "description": "Design-level patterns and architectural constraints for system design",
    "source": "industry/dos_and_donts.pdf",
    "target_agent": "LaravelArchitect",
    "role": "Designs system architecture following these patterns",
    "output": "docs/system_design/volopa_mass_payments.md"
  },

  "mental_model": {
    "description": "Core architectural flow that all designs must follow",
    "flow": "Client → route (versioned, throttled, auth) → controller → FormRequest (validation + policy) → domain logic (services/models/transactions) → API Resource (shape output) → JSON with correct status codes",
    "layers": {
      "routing_layer": {
        "responsibility": "API versioning, rate limiting, authentication",
        "design_pattern": "Versioned routes under /api/v1 with middleware"
      },
      "controller_layer": {
        "responsibility": "Route requests to domain logic",
        "design_pattern": "Thin controllers - no business logic"
      },
      "validation_layer": {
        "responsibility": "Input validation and authorization",
        "design_pattern": "FormRequests for validation, Policies for authorization"
      },
      "domain_layer": {
        "responsibility": "Business logic, data access, transactions",
        "design_pattern": "Services for complex logic, Models for data access"
      },
      "response_layer": {
        "responsibility": "Output transformation and formatting",
        "design_pattern": "API Resources to shape all responses"
      }
    }
  },

  "architectural_dos": {
    "routing_design": {
      "category": "API Structure Design",
      "requirements": [
        {
          "id": "ARCH-ROUTE-001",
          "requirement": "Design versioned routes under /api/v1",
          "rationale": "API versioning enables backward compatibility",
          "design_specification": "All routes in routes/api.php under /v1 prefix with auth middleware",
          "example": "Route::prefix('v1')->middleware('auth:api')->group(function () { ... })"
        },
        {
          "id": "ARCH-ROUTE-002",
          "requirement": "Design consistent route naming conventions",
          "rationale": "Consistent naming improves maintainability",
          "design_specification": "Use pattern: api.v1.{resource}.{action} (e.g., api.v1.payments.store)",
          "example": "Route::post('/mass-payments', [MassPaymentController::class, 'store'])->name('api.v1.mass-payments.store')"
        },
        {
          "id": "ARCH-ROUTE-003",
          "requirement": "Design authentication and rate limiting middleware",
          "rationale": "Security and performance protection at routing layer",
          "design_specification": "Apply auth middleware and throttling to all routes",
          "volopa_specific": "OAuth2 or WSSE custom authorization via middleware"
        }
      ]
    },

    "data_architecture": {
      "category": "Database Schema Design",
      "requirements": [
        {
          "id": "ARCH-DATA-001",
          "requirement": "Design database schema with migrations",
          "rationale": "Version-controlled schema changes",
          "design_specification": "Create migration plans for new tables (mass_payment_files, payment_instructions)",
          "includes": ["Table structure", "Column types", "Nullable constraints"]
        },
        {
          "id": "ARCH-DATA-002",
          "requirement": "Design model relationships",
          "rationale": "Define data relationships for ORM",
          "design_specification": "Specify belongsTo, hasMany, belongsToMany relationships",
          "example": "MassPaymentFile belongsTo TccAccount, hasMany PaymentInstruction"
        },
        {
          "id": "ARCH-DATA-003",
          "requirement": "Design database indexes and constraints",
          "rationale": "Query performance and data integrity",
          "design_specification": "Specify indexes on foreign keys, unique constraints, and frequently queried columns",
          "critical_indexes": ["Foreign keys", "Status columns", "client_id (tenant isolation)", "UUID primary keys"]
        }
      ]
    },

    "validation_architecture": {
      "category": "Validation & Authorization Design",
      "requirements": [
        {
          "id": "ARCH-VALID-001",
          "requirement": "Design FormRequest validation architecture",
          "rationale": "Centralized validation logic separate from controllers",
          "design_specification": "Create FormRequest classes for each endpoint with validation rules",
          "example": "UploadMassPaymentFileRequest, ApproveMassPaymentFileRequest"
        },
        {
          "id": "ARCH-VALID-002",
          "requirement": "Design Policy-based authorization",
          "rationale": "Centralized permission checks",
          "design_specification": "Create Policies with methods for each action (view, create, update, delete, approve)",
          "example": "MassPaymentFilePolicy with approve(), view(), delete() methods"
        },
        {
          "id": "ARCH-VALID-003",
          "requirement": "Design safe query filter architecture",
          "rationale": "Prevent SQL injection and query manipulation",
          "design_specification": "Define allowed filter fields, validate input before query building",
          "dont": "Don't build query filters directly from user input"
        }
      ]
    },

    "controller_service_architecture": {
      "category": "Controller-Service Separation Design",
      "requirements": [
        {
          "id": "ARCH-CTRL-001",
          "requirement": "Design thin controllers",
          "rationale": "Separation of concerns - controllers route, services contain logic",
          "design_specification": "Controllers should only: validate via FormRequest, authorize via Policy, delegate to service, return Resource",
          "max_controller_lines": "Controllers should rarely exceed 10-15 lines per method"
        },
        {
          "id": "ARCH-CTRL-002",
          "requirement": "Design service layer for business logic",
          "rationale": "Centralized, testable, reusable business logic",
          "design_specification": "Create service classes for complex operations (CsvValidationService, PaymentProcessingService)",
          "responsibility": "Services handle: multi-step operations, external API calls, complex validation, transaction coordination"
        },
        {
          "id": "ARCH-CTRL-003",
          "requirement": "Design proper HTTP status codes",
          "rationale": "RESTful API conventions",
          "design_specification": {
            "201": "Created (successful POST creating resource)",
            "204": "No Content (successful DELETE)",
            "200": "OK (successful GET/PUT)",
            "400": "Bad Request (malformed request)",
            "401": "Unauthorized (missing/invalid credentials)",
            "403": "Forbidden (authenticated but not authorized)",
            "404": "Not Found (resource doesn't exist)",
            "422": "Unprocessable Entity (validation failed)"
          },
          "dont": "Don't return 200 for errors"
        }
      ]
    },

    "transaction_architecture": {
      "category": "Transaction Boundary Design",
      "requirements": [
        {
          "id": "ARCH-TRANS-001",
          "requirement": "Design transaction boundaries for multi-write operations",
          "rationale": "Data integrity - all writes succeed or all fail",
          "design_specification": "Identify operations that write to multiple tables and wrap in DB::transaction()",
          "examples": [
            "Creating mass payment file + payment instructions (atomic operation)",
            "Approving payment file + updating status + creating audit log",
            "Deleting payment file + cascade deleting payment instructions"
          ],
          "dont": "Don't forget transactions for multi-write operations"
        },
        {
          "id": "ARCH-TRANS-002",
          "requirement": "Design transaction scope appropriately",
          "rationale": "Balance data integrity with performance",
          "design_specification": "Keep transactions small - only wrap necessary writes, avoid long-running operations inside transactions",
          "anti_pattern": "Don't include external API calls, file I/O, or email sending inside transactions"
        }
      ]
    },

    "query_performance_architecture": {
      "category": "N+1 Query Prevention Design",
      "requirements": [
        {
          "id": "ARCH-PERF-001",
          "requirement": "Design eager loading strategy to prevent N+1 queries",
          "rationale": "Performance - load related data in single query instead of loop",
          "design_specification": "Specify ->with(['relation']) for all relationships accessed in responses",
          "examples": [
            "MassPaymentFile::with(['client', 'paymentInstructions'])",
            "PaymentInstruction::with(['beneficiary', 'massPaymentFile.client'])"
          ],
          "critical_locations": "Especially critical in API Resource classes and list endpoints",
          "dont": "Don't create N+1 queries (especially in Resources)"
        },
        {
          "id": "ARCH-PERF-002",
          "requirement": "Design pagination for all list endpoints",
          "rationale": "Performance and memory - prevent unbounded result sets",
          "design_specification": "All list endpoints must use ->paginate(20) or ->simplePaginate()",
          "default_page_size": 20,
          "max_page_size": 100,
          "dont": "Don't return unbounded lists"
        }
      ]
    },

    "response_architecture": {
      "category": "API Response Design",
      "requirements": [
        {
          "id": "ARCH-RESP-001",
          "requirement": "Design API Resources for all responses",
          "rationale": "Consistent response structure, hide internal fields, decouple model from API",
          "design_specification": "Create API Resource classes that transform models to JSON, never return raw Eloquent models",
          "example": "MassPaymentFileResource, PaymentInstructionResource",
          "dont": "Don't return raw Eloquent models"
        },
        {
          "id": "ARCH-RESP-002",
          "requirement": "Design consistent response shapes and casing",
          "rationale": "API consistency and client expectations",
          "design_specification": "Use snake_case for JSON keys, consistent error format, consistent pagination structure",
          "error_format": {
            "message": "Human-readable error message",
            "errors": "Validation errors keyed by field"
          },
          "dont": "Don't respond with inconsistent shapes/casing"
        },
        {
          "id": "ARCH-RESP-003",
          "requirement": "Design pagination response structure",
          "rationale": "Standardized pagination format for clients",
          "design_specification": "Use Resource::collection($query->paginate()) for paginated collections",
          "response_structure": {
            "data": "Array of resources",
            "links": "Pagination links (first, last, prev, next)",
            "meta": "Pagination metadata (current_page, total, per_page)"
          }
        }
      ]
    },

    "async_processing_architecture": {
      "category": "Asynchronous Processing Design",
      "requirements": [
        {
          "id": "ARCH-ASYNC-001",
          "requirement": "Design queue jobs for large file operations",
          "rationale": "Prevent request timeouts, improve responsiveness",
          "design_specification": "Operations processing >1000 rows or >30 seconds should be queued",
          "volopa_context": "CSV files can contain up to 10,000 payment instructions",
          "examples": [
            "ValidateMassPaymentFileJob (validate CSV with 10k rows)",
            "ProcessPaymentInstructionsJob (create payment records)"
          ],
          "dont": "Don't let file uploads bloat the API process"
        },
        {
          "id": "ARCH-ASYNC-002",
          "requirement": "Design status polling pattern for async operations",
          "rationale": "Client needs to track progress of long-running operations",
          "design_specification": "Return 201 Created with status='processing', provide GET endpoint to poll status",
          "status_flow": "uploading → validating → validation_failed/validation_successful → pending_approval → approved → completed"
        }
      ]
    },

    "caching_architecture": {
      "category": "Caching Strategy Design",
      "requirements": [
        {
          "id": "ARCH-CACHE-001",
          "requirement": "Design caching strategy for reference data",
          "rationale": "Performance - reduce database queries for frequently accessed data",
          "design_specification": "Cache immutable or rarely-changing reference data",
          "examples": [
            "Currency codes (TTL: 1 day)",
            "Purpose codes by country+currency (TTL: 1 hour)",
            "Client feature flags (TTL: 5 minutes)"
          ],
          "dont": "Don't ignore caching"
        },
        {
          "id": "ARCH-CACHE-002",
          "requirement": "Design cache invalidation strategy",
          "rationale": "Ensure cache consistency with database",
          "design_specification": "Define cache invalidation triggers (admin updates, TTL expiration)",
          "methods": "Cache::forget(), Cache::tags(), Cache::flush()"
        }
      ]
    },

    "security_architecture": {
      "category": "Security Design",
      "requirements": [
        {
          "id": "ARCH-SEC-001",
          "requirement": "Design stateless API architecture",
          "rationale": "APIs should not rely on server-side sessions",
          "design_specification": "Use token-based authentication (OAuth2, WSSE), no session/redirect patterns",
          "volopa_specific": "Custom authorization via OAuth2 access tokens or WSSE credentials",
          "dont": "Don't use session/redirect patterns in APIs"
        },
        {
          "id": "ARCH-SEC-002",
          "requirement": "Design tenant isolation architecture",
          "rationale": "Multi-tenant security - users only access their client's data",
          "design_specification": "All queries filtered by client_id, enforce at global scope level",
          "implementation": "Global scope on models, middleware enforcement, Policy checks",
          "volopa_specific": "client_id on all tenant-scoped tables"
        },
        {
          "id": "ARCH-SEC-003",
          "requirement": "Design safe input handling",
          "rationale": "Prevent injection attacks and mass-assignment vulnerabilities",
          "design_specification": "Validate all input via FormRequests, use $fillable/$guarded on models",
          "dont": "Don't disable mass-assignment protection or trust client-owned fields"
        }
      ]
    }
  },

  "architectural_donts": {
    "response_anti_patterns": [
      {
        "id": "ARCH-DONT-001",
        "anti_pattern": "Returning raw Eloquent models in API responses",
        "why_bad": "Exposes internal structure, couples API to database schema, leaks sensitive fields",
        "correct_design": "Always design API Resources to transform models to controlled JSON structure",
        "example_bad": "return MassPaymentFile::find($id);",
        "example_good": "return new MassPaymentFileResource(MassPaymentFile::find($id));"
      },
      {
        "id": "ARCH-DONT-002",
        "anti_pattern": "Using session/redirect patterns in APIs",
        "why_bad": "APIs should be stateless, sessions break RESTful design",
        "correct_design": "Design token-based authentication, return JSON responses with status codes"
      },
      {
        "id": "ARCH-DONT-003",
        "anti_pattern": "Returning 200 status code for errors",
        "why_bad": "Violates HTTP semantics, confuses clients",
        "correct_design": "Design proper status codes: 400 (bad request), 401 (unauthorized), 403 (forbidden), 404 (not found), 422 (validation failed)"
      },
      {
        "id": "ARCH-DONT-004",
        "anti_pattern": "Inconsistent response shapes or casing",
        "why_bad": "Breaks client expectations, requires special handling",
        "correct_design": "Design consistent response format (snake_case), consistent error structure, consistent pagination format"
      }
    ],

    "query_anti_patterns": [
      {
        "id": "ARCH-DONT-005",
        "anti_pattern": "Building query filters directly from user input",
        "why_bad": "SQL injection risk, allows unauthorized data access",
        "correct_design": "Design whitelist of allowed filter fields, validate input before query building"
      },
      {
        "id": "ARCH-DONT-006",
        "anti_pattern": "N+1 queries in list endpoints or Resources",
        "why_bad": "Performance degradation - 1 query becomes N+1 queries in loop",
        "correct_design": "Design eager loading strategy: ->with(['relation']) for all accessed relationships",
        "example": "MassPaymentFile::with(['client', 'paymentInstructions'])->paginate()"
      },
      {
        "id": "ARCH-DONT-007",
        "anti_pattern": "Returning unbounded lists",
        "why_bad": "Memory exhaustion, slow responses, potential DoS",
        "correct_design": "Design pagination for ALL list endpoints: ->paginate(20)"
      }
    ],

    "data_integrity_anti_patterns": [
      {
        "id": "ARCH-DONT-008",
        "anti_pattern": "Multi-write operations without transactions",
        "why_bad": "Data inconsistency if one write succeeds and another fails",
        "correct_design": "Design transaction boundaries: DB::transaction() wrapping all related writes",
        "example": "Creating payment file + instructions, approving file + audit log"
      }
    ],

    "performance_anti_patterns": [
      {
        "id": "ARCH-DONT-009",
        "anti_pattern": "Ignoring caching for reference data",
        "why_bad": "Repeated database queries for rarely-changing data",
        "correct_design": "Design caching strategy for currencies, purpose codes, feature flags"
      },
      {
        "id": "ARCH-DONT-010",
        "anti_pattern": "Synchronous processing of large file uploads",
        "why_bad": "Request timeouts, poor user experience, resource blocking",
        "correct_design": "Design async job architecture for files >1000 rows, return 201 with status='processing'"
      }
    ]
  },

  "volopa_specific_architecture": {
    "authentication": {
      "methods": ["OAuth2", "WSSE"],
      "design_specification": "Custom authorization via middleware, not standard Laravel auth",
      "middleware": "Apply Volopa's custom auth middleware to all routes"
    },
    "tenant_isolation": {
      "pattern": "client_id on all tables",
      "design_specification": "All queries filtered by authenticated user's client_id",
      "enforcement": "Global scope, middleware, policy checks"
    },
    "multi_tenant": {
      "enabled": true,
      "design_specification": "All user actions scoped to their client, no cross-client data access"
    }
  },

  "usage_instructions": {
    "when_to_apply": "During WriteDesign action when creating system architecture",
    "how_to_apply": "LaravelArchitect loads this file in constructor, injects into constraints field",
    "output_sections": [
      "Data Models (with relationships, indexes, constraints)",
      "API Endpoint Design (routes, middleware, versioning)",
      "Service Layer Architecture (business logic separation)",
      "Transaction Boundaries (multi-write operations)",
      "Eager Loading Strategy (N+1 prevention)",
      "Pagination Requirements (all list endpoints)",
      "API Resource Design (response transformation)",
      "Async Job Architecture (large file processing)",
      "Caching Strategy (reference data)",
      "Security Design (auth, tenant isolation, validation)"
    ],
    "validation": "System design must address all ARCH-* requirements and avoid all ARCH-DONT-* anti-patterns"
  }
}
